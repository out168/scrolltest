{"name":"Smooth double layered scroll for screen 4 and MSX2+ ","body":"# Fake double layered horizontal scroll in screen 4\r\n\r\nI guess this technique is known and perhaps has even been used in some project.  \r\nAnyway, i wish to share the source code of this little demo.\r\n\r\nUsing the hardware horizontal scroll capabilites and some trickery, it is \r\npossible to do a double layered scroll pixel by pixel in screen 4. Actually, \r\nthe front layer moves by 2 pixels, while the background layer moves by 1 pixel.\r\n\r\nThe scroll is done every 1/15 seconds aproximately. In theory is possible to \r\nupdate the screen every 1/60 seconds, although the results are not very \r\npleasing to look at (flickering). Perhaps if an alternative technique is used \r\n(see the Extensions section), the scroll will also look good at 1/30 seconds.\r\n\r\n### WARNING\r\n\r\nI have ran this on openmsx only. Don't know if there are too fast vdp access \r\nproblems.\r\n\r\n### Requirements\r\n\r\nThis code is designed for the V9958.\r\n16 kB of ram are assumed to be present on page 3 ($c000-$ffff).\r\n\r\nThe \"game\" area is 32x20 tiles (Maze of Galious size). This leaves 4 tiles for \r\ninformation.  Some sort of scroll split will be required (it is not implemented \r\nin this example: the first four lines are black).\r\n\r\nIncrease game area and you get screen flickering. Perhaps this side effect could \r\nbe reduced optimizing the source code.\r\n\r\n### Tile trickery\r\n\r\nThe idea is simple.\r\n\r\nFor this example i use 16 tiles arranged in a 4x4 square. I use only 2 colors \r\nfor the square to avoid color clash. However, two colors per horizontal 32 pixel \r\nline are possible in this arrangement (i mean, background tiles having different \r\ncolors vertically).\r\n\r\nPlease take into account that, in this case, each horizontal\r\narrangement of tiles should have the same exact color: that is, for instance,\r\n$fe,$fe,$fe,$fe. If you use bmp2msx converter, some tiles may get the\r\n\"wrong\" $ef color. Beware of that! (for me, this was a cause of some headaches!)\r\n\r\nThere is nothing particular about this 4x4 arrangement. Of course you can\r\nuse any arrangement you like (4x8, 8x4, 6x6...), but take into account\r\nthat the more tiles, the more memory will you need to store all the tiles.\r\n\r\nI generate 8 background tilesets (8x16=128 tiles), each one of them rotated one \r\npixel to the left of the other:  that's the reason of the two colors per \r\nhorizontal line restriction. In this example, i am restricted to two colors per \r\n32 horizontal pixels. These tilesets are stored in RAM, addresses $c100 to $c4ff \r\n(128 tiles x 8 bytes /tile = $400 bytes). Only the patters are rotated, the \r\ncolors need not to be rotated in this example.\r\n\r\nLet's consider scrolling to the left. The screen is horizontally scrolled by \r\nsetting the appropriate registers of V9958 that displace the screen by 2 pixels.  \r\nEach time the screen is scrolled, the background tileset gets substituted by the \r\nthe one corresponding to one pixel *right* rotated version of the actual \r\nbackground tileset. By doing this, the background tiles will appear to be moved \r\none pixel to the left (2pixels to the left from hardware scroll + 1 pixel to the \r\nright from \"tile scroll\" = 1 pixel to the left, while the foreground layer has \r\nbeen moved 2 pixels to the left).\r\n\r\n### Extensions\r\n\r\nNote that this can be used with V9938 if the hardware scroll is changed to a \r\n\"set adjust\" scroll.\r\n\r\nIf this technique is used for vertical scrolling, then the V9938 can handle it \r\nas well, and furthermore the two color per line restriction does not apply: \r\nbackground and foreground tiles share only the 2 color per 8 pixel constraint. \r\n\r\nNote that for the vertical scolling case, the color data needs to be rotated and \r\nstored also (doubling the memory requirements).\r\n\r\nOn the other hand, given that the minimum VRAM of the V9938/V9958 is 128kB, and\r\nprovided that you are ok with just 8 tilesets (and for a repetitive background\r\nconfiguration such as a repetition of a n times m tile block i think you are),\r\nyou could store all the tilesets in the vram, and the \"tile scroll\" is just a\r\nchange on the base address of the pattern generator and color tables.  This\r\nchange involves a few out instructions i think. Furthermore, no RAM memory will\r\nbe required to store the tilesets!\r\n\r\nOn the current implementation, the \"tile scroll\" involves a transfer of\r\n128x3=384 bytes each time the screen is scrolled: 16 tiles x 8 bytes\r\n/tile=128 bytes, and multiplied by 3 because three tilesets compose a\r\nscreen.\r\n\r\n### Conclusions\r\n\r\nI don't know if the operations that need to be performed are too heavy. I also \r\ndon't know if a game (say, a shoot'em'up) is possible using this technique. \r\n\r\nIf you want pixel perfect, double layer horizontal/vertical scrolling on MSX, \r\nuse the V9990!\r\n\r\nPerhaps, using this method, you can get triple or quadruple layer pixel scroll \r\nwith V9990.\r\n\r\n### Contact\r\n\r\nusername qilipalmer at the mail service of the searching company.\r\n","tagline":"","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}